"use strict";
// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter
Object.defineProperty(exports, "__esModule", { value: true });
exports.versionCommand = exports.kitchenSink = exports.commandInit = exports.commandHelp = exports.commandError = exports.commandBuild = exports.setTypewriterOptions = exports.defaultValidationErrorHandler = exports.AnEnum = exports.Mode = exports.TokenType = void 0;
const tslib_1 = require("tslib");
/**
 * Type of token retrieval
 */
var TokenType;
(function (TokenType) {
    TokenType["Global"] = "global";
    TokenType["Input"] = "input";
    TokenType["Script"] = "script";
})(TokenType = exports.TokenType || (exports.TokenType = {}));
/**
 * Build Output mode
 */
var Mode;
(function (Mode) {
    Mode["Dev"] = "dev";
    Mode["Prod"] = "prod";
})(Mode = exports.Mode || (exports.Mode = {}));
var AnEnum;
(function (AnEnum) {
    AnEnum["Another"] = "another";
    AnEnum["Value"] = "value";
})(AnEnum = exports.AnEnum || (exports.AnEnum = {}));
/**
 * Ajv is a peer dependency for development builds. It's used to apply run-time validation
 * to message payloads before passing them on to the underlying analytics instance.
 *
 * Note that the production bundle does not depend on Ajv.
 *
 * You can install it with: `npm install --save-dev ajv`.
 */
const ajv_1 = tslib_1.__importDefault(require("ajv"));
/**
 * The default handler that is fired if none is supplied with setTypewriterOptions.
 * If NODE_ENV="test", this handler will throw an error. Otherwise, it will log
 * a warning message to the console.
 */
const defaultValidationErrorHandler = (message, violations) => {
    const msg = JSON.stringify({
        type: 'Typewriter JSON Schema Validation Error',
        description: `You made an analytics call (${message.event}) using Typewriter that doesn't match the ` +
            'Tracking Plan spec.',
        errors: violations,
    }, undefined, 2);
    if (process.env.NODE_ENV === 'test') {
        throw new Error(msg);
    }
    console.warn(msg);
};
exports.defaultValidationErrorHandler = defaultValidationErrorHandler;
let onViolation = exports.defaultValidationErrorHandler;
const missingAnalyticsNodeError = new Error(`You must set an analytics-node instance:

>	const SegmentAnalytics = require('analytics-node')
>	const { setTypewriterOptions } = require('./analytics')
>
>	const analytics = new SegmentAnalytics('SEGMENT_WRITE_KEY')
>	setTypewriterOptions({
>		analytics: analytics,
>	})

For more information on analytics-node, see: https://segment.com/docs/sources/server/node/quickstart/
`);
let analytics = () => {
    throw missingAnalyticsNodeError;
};
/**
 * Updates the run-time configuration of this Typewriter client.
 * This function must be called with a configured analytics-node instance before firing
 * any analytics calls, or else a `missingAnalyticsNodeError` error will be thrown.
 *
 * @param {TypewriterOptions} options - the options to upsert
 *
 * @typedef {Object} TypewriterOptions
 * @property {AnalyticsNode} analytics - Underlying analytics instance where analytics
 * 		calls are forwarded on to.
 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
 * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
 * 		will be logged to stderr.
 */
function setTypewriterOptions(options) {
    analytics = options.analytics ? () => options.analytics : analytics;
    onViolation = options.onViolation || onViolation;
}
exports.setTypewriterOptions = setTypewriterOptions;
/**
    * Validates a message against a JSON Schema using Ajv. If the message
    * is invalid, the `onViolation` handler will be called.
    */
function validateAgainstSchema(message, schema) {
    const ajv = new ajv_1.default({ allErrors: true, verbose: true });
    if (!ajv.validate(schema, message.properties) && ajv.errors) {
        onViolation(message, ajv.errors);
    }
}
/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext(message) {
    return {
        ...message,
        context: {
            ...(message.context || {}),
            typewriter: {
                language: 'typescript',
                version: '8.0.8',
            },
        },
    };
}
/**
 * Fires a 'Command Build' track call.
 * Fired when the user generates code with Typewriter
 *
 * @param {TrackMessage<CommandBuild>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function commandBuild(message, callback) {
    const schema = { "$id": "Command Build", "$schema": "http://json-schema.org/draft-07/schema#", "description": "Fired when the user generates code with Typewriter", "properties": { "config": { "$id": "/properties/config", "description": "Local Workspace configuration", "properties": { "language": { "$id": "/properties/properties/properties/config/properties/language", "description": "Language to Generate", "type": "string" }, "languageOptions": { "$id": "/properties/properties/properties/config/properties/languageOptions", "description": "Advanced Language Options", "type": "object" }, "sdk": { "$id": "/properties/properties/properties/config/properties/sdk", "description": "SDK to generate", "type": "string" }, "tokenType": { "$id": "/properties/properties/properties/config/properties/tokenType", "description": "Type of token retrieval", "enum": ["global", "input", "script"], "type": "string" }, "trackingPlans": { "$id": "/properties/properties/properties/config/properties/trackingPlans", "description": "Tracking Plans to generate code for", "items": { "$id": "/properties/properties/properties/config/properties/trackingPlans/items", "description": "", "properties": { "id": { "$id": "/properties/properties/properties/config/properties/trackingPlans/items/properties/id", "description": "Tracking Plan ID", "type": "string" }, "path": { "$id": "/properties/properties/properties/config/properties/trackingPlans/items/properties/path", "description": "Path to output code", "type": "string" } }, "required": [], "type": "object" }, "type": "array" } }, "required": ["trackingPlans", "language", "sdk"], "type": "object" }, "duration": { "$id": "/properties/duration", "description": "Duration of the command in ms", "type": "number" }, "isCI": { "$id": "/properties/isCI", "description": "Runs in a CI environment", "type": "string" }, "mode": { "$id": "/properties/mode", "description": "Build Output mode", "enum": ["dev", "prod"], "type": "string" }, "rawCommand": { "$id": "/properties/rawCommand", "description": "Raw command string input", "type": "string" }, "workspace": { "$id": "/properties/workspace", "description": "User Segment Workspace", "type": "string" } }, "required": ["workspace", "config", "mode", "duration", "isCI", "rawCommand"], "type": "object" };
    const event = withTypewriterContext({
        ...message,
        event: 'Command Build',
        properties: {
            ...message.properties,
        },
    });
    validateAgainstSchema(event, schema);
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.commandBuild = commandBuild;
/**
 * Fires a 'Command Error' track call.
 *
 *
 * @param {TrackMessage<CommandError>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function commandError(message, callback) {
    const schema = { "$id": "Command Error", "$schema": "http://json-schema.org/draft-07/schema#", "properties": { "config": { "$id": "/properties/config", "description": "Local Workspace configuration", "properties": { "language": { "$id": "/properties/properties/properties/config/properties/language", "description": "Language to generate", "type": "string" }, "languageOptions": { "$id": "/properties/properties/properties/config/properties/languageOptions", "description": "Advanced Language Options", "type": "object" }, "sdk": { "$id": "/properties/properties/properties/config/properties/sdk", "description": "SDK to generate", "type": "string" }, "tokenType": { "$id": "/properties/properties/properties/config/properties/tokenType", "description": "Type of token retrieval", "enum": ["global", "input", "script"], "type": "string" }, "trackingPlans": { "$id": "/properties/properties/properties/config/properties/trackingPlans", "description": "Tracking Plans to generate code for", "items": { "$id": "/properties/properties/properties/config/properties/trackingPlans/items", "description": "", "properties": { "id": { "$id": "/properties/properties/properties/config/properties/trackingPlans/items/properties/id", "description": "Tracking Plan ID", "type": "string" }, "path": { "$id": "/properties/properties/properties/config/properties/trackingPlans/items/properties/path", "description": "Path to output code", "type": "string" } }, "required": [], "type": "object" }, "type": "array" } }, "required": ["trackingPlans", "language", "sdk"], "type": "object" }, "error": { "$id": "/properties/error", "description": "Error Object", "type": "object" }, "errorCode": { "$id": "/properties/errorCode", "description": "Exit code for the error", "type": "number" }, "errorMessage": { "$id": "/properties/errorMessage", "description": "User friendly error message", "type": "string" }, "isCI": { "$id": "/properties/isCI", "description": "Runs in a CI environment", "type": "string" }, "rawCommand": { "$id": "/properties/rawCommand", "description": "Raw command string input", "type": "string" }, "workspace": { "$id": "/properties/workspace", "description": "User Segment Workspace", "type": "string" } }, "required": ["isCI", "rawCommand", "errorMessage", "error"], "type": "object" };
    const event = withTypewriterContext({
        ...message,
        event: 'Command Error',
        properties: {
            ...message.properties,
        },
    });
    validateAgainstSchema(event, schema);
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.commandError = commandError;
/**
 * Fires a 'Command Help' track call.
 *
 *
 * @param {TrackMessage<CommandHelp>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function commandHelp(message, callback) {
    const schema = { "$id": "Command Help", "$schema": "http://json-schema.org/draft-07/schema#", "properties": { "rawCommand": { "$id": "/properties/rawCommand", "description": "Raw command string input", "type": "string" } }, "required": ["rawCommand"], "type": "object" };
    const event = withTypewriterContext({
        ...message,
        event: 'Command Help',
        properties: {
            ...message.properties,
        },
    });
    validateAgainstSchema(event, schema);
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.commandHelp = commandHelp;
/**
 * Fires a 'Command Init' track call.
 * Init Events that initialize the settings for typewriter
 *
 * @param {TrackMessage<CommandInit>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function commandInit(message, callback) {
    const schema = { "$id": "Command Init", "$schema": "http://json-schema.org/draft-07/schema#", "description": "Init Events that initialize the settings for typewriter", "labels": { "init": "initialize" }, "properties": { "config": { "$id": "/properties/config", "description": "Local Workspace configuration", "properties": { "language": { "$id": "/properties/properties/properties/config/properties/language", "description": "Language to generate", "type": "string" }, "languageOptions": { "$id": "/properties/properties/properties/config/properties/languageOptions", "description": "Advanced Language Options", "type": "object" }, "sdk": { "$id": "/properties/properties/properties/config/properties/sdk", "description": "SDK to generate", "type": "string" }, "tokenType": { "$id": "/properties/properties/properties/config/properties/tokenType", "description": "Type of token retrieval", "enum": ["global", "input", "script"], "type": "string" }, "trackingPlans": { "$id": "/properties/properties/properties/config/properties/trackingPlans", "description": "Tracking Plans to generate code for", "items": { "$id": "/properties/properties/properties/config/properties/trackingPlans/items", "description": "", "properties": { "id": { "$id": "/properties/properties/properties/config/properties/trackingPlans/items/properties/id", "description": "Tracking Plan ID", "type": "string" }, "path": { "$id": "/properties/properties/properties/config/properties/trackingPlans/items/properties/path", "description": "Path to output code", "type": "string" } }, "required": ["id", "path"], "type": "object" }, "type": "array" }, "workspace": { "$id": "/properties/properties/properties/config/properties/workspace", "description": "User Segment Workspace", "type": "string" } }, "required": ["language", "sdk", "tokenType", "workspace", "trackingPlans"], "type": "object" }, "duration": { "$id": "/properties/duration", "description": "Duration of the command in ms", "type": "number" }, "hasConfig": { "$id": "/properties/hasConfig", "description": "Wether there is a workspace config already present", "type": "boolean" }, "rawCommand": { "$id": "/properties/rawCommand", "description": "Raw command string input", "type": "string" } }, "required": ["config", "rawCommand", "duration"], "type": "object" };
    const event = withTypewriterContext({
        ...message,
        event: 'Command Init',
        properties: {
            ...message.properties,
        },
    });
    validateAgainstSchema(event, schema);
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.commandInit = commandInit;
/**
 * Fires a 'KitchenSink' track call.
 * KitchenSink Event for testing all possible data types
 *
 * @param {TrackMessage<KitchenSink>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function kitchenSink(message, callback) {
    const schema = { "$id": "KitchenSink", "$schema": "http://json-schema.org/draft-07/schema#", "description": "KitchenSink Event for testing all possible data types", "properties": { "aBoolean": { "$id": "/properties/aBoolean", "description": "", "type": "boolean" }, "aDate": { "$id": "/properties/aDate", "description": "", "format": "date-time", "type": "string" }, "aNumber": { "$id": "/properties/aNumber", "description": "", "type": "number" }, "aString": { "$id": "/properties/aString", "description": "", "type": "string" }, "anArray": { "$id": "/properties/anArray", "description": "", "type": "array" }, "anEnum": { "$id": "/properties/anEnum", "description": "", "enum": ["another", "value"], "type": "string" }, "anInteger": { "$id": "/properties/anInteger", "description": "", "type": "integer" }, "anObject": { "$id": "/properties/anObject", "description": "", "type": "object" }, "anything": { "$id": "/properties/anything", "description": "" } }, "type": "object" };
    const event = withTypewriterContext({
        ...message,
        event: 'KitchenSink',
        properties: {
            ...message.properties,
        },
    });
    validateAgainstSchema(event, schema);
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.kitchenSink = kitchenSink;
/**
 * Fires a 'VersionCommand' track call.
 *
 *
 * @param {TrackMessage<VersionCommand>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function versionCommand(message, callback) {
    const schema = { "$id": "VersionCommand", "$schema": "http://json-schema.org/draft-07/schema#", "properties": { "version": { "$id": "/properties/version", "description": "", "type": "string" } }, "required": ["version"], "type": "object" };
    const event = withTypewriterContext({
        ...message,
        event: 'VersionCommand',
        properties: {
            ...message.properties,
        },
    });
    validateAgainstSchema(event, schema);
    const a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.versionCommand = versionCommand;
const clientAPI = {
    /**
     * Updates the run-time configuration of this Typewriter client.
     * This function must be called with a configured analytics-node instance before firing
     * any analytics calls, or else a `missingAnalyticsNodeError` error will be thrown.
     *
     * @param {TypewriterOptions} options - the options to upsert
     *
     * @typedef {Object} TypewriterOptions
     * @property {AnalyticsNode} analytics - Underlying analytics instance where analytics
     * 		calls are forwarded on to.
     * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
     * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
     * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
     * 		will be logged to stderr.
     */
    setTypewriterOptions,
    /**
     * Fires a 'Command Build' track call.
     * Fired when the user generates code with Typewriter
     *
     * @param CommandBuild props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    commandBuild,
    /**
     * Fires a 'Command Error' track call.
     *
     *
     * @param CommandError props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    commandError,
    /**
     * Fires a 'Command Help' track call.
     *
     *
     * @param CommandHelp props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    commandHelp,
    /**
     * Fires a 'Command Init' track call.
     * Init Events that initialize the settings for typewriter
     *
     * @param CommandInit props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    commandInit,
    /**
     * Fires a 'KitchenSink' track call.
     * KitchenSink Event for testing all possible data types
     *
     * @param KitchenSink props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    kitchenSink,
    /**
     * Fires a 'VersionCommand' track call.
     *
     *
     * @param VersionCommand props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    versionCommand,
};
exports.default = new Proxy(clientAPI, {
    get(target, method) {
        if (typeof method === 'string' && target.hasOwnProperty(method)) {
            return target[method];
        }
        return () => {
            console.warn(`⚠️  You made an analytics call (${String(method)}) that can't be found. Either:
         a) Re-generate your typewriter client: \`npx typewriter\`
         b) Add it to your Tracking Plan: https://app.segment.com/segment-oscb/protocols/tracking-plans/rs_1zTHJU9fd5mt7cndWnd4PgJbMCE`);
            const a = analytics();
            if (a) {
                a.track(withTypewriterContext({
                    event: 'Unknown Analytics Call Fired',
                    properties: {
                        method,
                    },
                    userId: 'typewriter',
                }));
            }
        };
    },
});
