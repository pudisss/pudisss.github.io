"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toTrackingPlanURL = exports.sanitizeTrackingPlan = exports.loadTrackingPlans = exports.writeTrackingPlan = exports.loadTrackingPlan = exports.TRACKING_PLAN_FILENAME = void 0;
const tslib_1 = require("tslib");
const debug_1 = require("debug");
const json_stable_stringify_1 = tslib_1.__importDefault(require("json-stable-stringify"));
const lodash_1 = require("lodash");
const node_fs_1 = tslib_1.__importDefault(require("node:fs"));
const node_util_1 = require("node:util");
const sort_keys_1 = tslib_1.__importDefault(require("sort-keys"));
const common_1 = require("../common");
const config_1 = require("../config");
const api_1 = require("./api");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const core_1 = require("@oclif/core");
const debug = (0, debug_1.debug)("typewriter:trackingplans");
const writeFile = (0, node_util_1.promisify)(node_fs_1.default.writeFile);
const readFile = (0, node_util_1.promisify)(node_fs_1.default.readFile);
exports.TRACKING_PLAN_FILENAME = "plan.json";
function isV1Plan(plan) {
    var _a;
    return !Array.isArray(plan.rules) && ((_a = plan.rules) === null || _a === void 0 ? void 0 : _a.events) !== undefined;
}
function convertToV2Plan(plan) {
    var _a;
    console.warn(`${chalk_1.default.yellow("Warning:")} The tracking plan ${plan.name} was downloaded with Typewriter v7, we will convert it for compatibility. However we recommend runing ${chalk_1.default.green("typewriter update")} or ${chalk_1.default.green("typewriter build -u")} to download it with v8 format`);
    return {
        createdAt: plan.create_time,
        updatedAt: plan.update_time,
        name: plan.display_name,
        id: plan.name.split("/").pop(),
        description: "",
        slug: "",
        rules: (_a = plan.rules) === null || _a === void 0 ? void 0 : _a.events.map((rule) => {
            return {
                key: rule.name,
                description: rule.description,
                jsonSchema: rule.rules,
                type: api_1.SegmentAPI.RuleType.Track,
                version: rule.version,
            };
        }),
    };
}
async function loadTrackingPlan(configPath, config) {
    const path = (0, config_1.resolveRelativePath)(configPath, config.path, exports.TRACKING_PLAN_FILENAME);
    // Load the Tracking Plan from the local cache.
    try {
        const plan = JSON.parse(await readFile(path, {
            encoding: "utf-8",
        }));
        let v2Plan;
        if (isV1Plan(plan)) {
            // Convert plan to v2 format internally
            debug(`Tracking Plan at ${path} is using ConfigAPI format. Translating to PublicAPI format for compatibility`);
            v2Plan = convertToV2Plan(plan);
        }
        else {
            v2Plan = plan;
        }
        return await sanitizeTrackingPlan(v2Plan);
    }
    catch {
        // We failed to read the Tracking Plan, possibly because no plan.json exists.
        return undefined;
    }
}
exports.loadTrackingPlan = loadTrackingPlan;
async function writeTrackingPlan(configPath, plan, config) {
    const path = (0, config_1.resolveRelativePath)(configPath, config.path, exports.TRACKING_PLAN_FILENAME);
    await (0, config_1.verifyDirectoryExists)(path, "file");
    // Perform some pre-processing on the Tracking Plan before writing it.
    const planJSON = (0, lodash_1.flow)(
    // Enforce a deterministic ordering to reduce verson control deltas.
    (plan) => sanitizeTrackingPlan(plan), (plan) => (0, json_stable_stringify_1.default)(plan, { space: "\t" }))(plan);
    await writeFile(path, planJSON, {
        encoding: "utf-8",
    });
}
exports.writeTrackingPlan = writeTrackingPlan;
/**
 * Loads tracking plan data for each of the tracking plan IDs in the user config.
 *
 * @param configPath path to the user config
 * @param trackingPlanConfigs array of tracking plan IDs
 * @param forceUpdate (default: false)
 * @returns Full TrackingPlan data
 */
async function loadTrackingPlans(apiToken, configPath, trackingPlanConfigs, forceUpdate = false) {
    var _a;
    const loadedTrackingPlans = [];
    for (const trackingPlanConfig of trackingPlanConfigs) {
        // Load the local copy of this Tracking Plan, we'll either use this for generation
        // or use it to identify what changed with the latest copy of this Tracking Plan.
        const previousTrackingPlan = await loadTrackingPlan(configPath, trackingPlanConfig);
        const planName = (_a = trackingPlanConfig.name) !== null && _a !== void 0 ? _a : trackingPlanConfig.id;
        if (previousTrackingPlan !== undefined) {
            core_1.CliUx.ux.action.status = `Loaded tracking plan from file: ${previousTrackingPlan.name}`;
            debug(`Loaded previous tracking plan: ${previousTrackingPlan.name}`);
        }
        // If we don't have a copy of the Tracking Plan, then we would fatal error. Instead,
        // fallback to pulling down a new copy of the Tracking Plan.
        if (!forceUpdate && previousTrackingPlan === undefined) {
            core_1.CliUx.ux.action.status = `No local copy found for ${planName}, fetching from API.`;
            debug("No local copy of this Tracking Plan, fetching from API.");
        }
        // If we are pulling the latest Tracking Plan (npx typewriter), or if there is no local
        // copy of the Tracking Plan (plan.json), then query the API for the latest Tracking Plan.
        let newTrackingPlan;
        if (forceUpdate || previousTrackingPlan === undefined) {
            try {
                core_1.CliUx.ux.action.status = `Fetching tracking plan ${planName}.`;
                newTrackingPlan = await (0, api_1.fetchTrackingPlan)(trackingPlanConfig.id, apiToken);
            }
            catch (error) {
                const errorMessage = (0, common_1.isWrappedError)(error)
                    ? error.description
                    : "API request failed";
                debug(`${errorMessage}. Using local copy of ${planName} instead.`);
                core_1.CliUx.ux.action.status = `Error fetching tracking plan ${planName}, using local copy instead.`;
            }
            if (newTrackingPlan !== undefined) {
                core_1.CliUx.ux.action.status = `Updating local copy of tracking plan ${planName}.`;
                // Update plan.json with the latest Tracking Plan.
                await writeTrackingPlan(configPath, newTrackingPlan, trackingPlanConfig);
                core_1.CliUx.ux.action.status = `Plan ${planName} updated.`;
            }
        }
        newTrackingPlan = newTrackingPlan || previousTrackingPlan;
        if (newTrackingPlan === undefined) {
            throw new Error("Unable to fetch Tracking Plan from local cache or API");
        }
        const rules = newTrackingPlan.rules;
        if (rules === undefined || rules.length === 0) {
            throw new Error(`No rules found for ${trackingPlanConfig.name}.`);
        }
        loadedTrackingPlans.push(newTrackingPlan);
    }
    return loadedTrackingPlans;
}
exports.loadTrackingPlans = loadTrackingPlans;
/**
 * Sanitizes key names removing unsupported characters of the JSON Schema
 * @param key key or name
 * @returns sanitized key
 */
function sanitizeKey(key) {
    return key.replace("#", "");
}
/**
 * Unwraps the properties so that they are not double nested inside .properties.properties
 * Also fixes the key property (non-breaking)
 */
const fixProperties = (plan) => {
    var _a, _b, _c, _d;
    // If we added the eventMetadata we have already done this unwrapping, no need to do it again
    if (plan.jsonSchema.eventMetadata !== undefined) {
        return plan;
    }
    const innerProperties = (_c = (_b = (_a = plan.jsonSchema.properties) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.properties) !== null && _c !== void 0 ? _c : {};
    Object.keys(innerProperties).map((key) => {
        if (innerProperties[key].id !== undefined) {
            innerProperties[key].id = innerProperties[key].id.replace("/properties/properties/properties/", "/properties/");
        }
    });
    return {
        ...plan,
        key: sanitizeKey(plan.key),
        jsonSchema: {
            ...plan.jsonSchema,
            ...(_d = plan.jsonSchema.properties) === null || _d === void 0 ? void 0 : _d.properties,
            properties: innerProperties,
            // We add some additional properties:
            eventMetadata: {
                name: plan.key,
                type: plan.type, // Event Type (Track, Identify, etc)
            },
        },
    };
};
const getChildrenOfProp = (obj, prop) => {
    const dictionary = obj[prop];
    if (dictionary !== undefined && dictionary !== null) {
        return Object.keys(dictionary).map((k) => dictionary[k]);
    }
    return [];
};
/**
 * Fixes the id -> $id issue of the API JSONSchema objects as AJV will mark them as non-compliant to the Schema Draft7+
 */
const fixJSONSchemaIds = (plan) => {
    if (plan.jsonSchema.$id !== undefined) {
        return plan;
    }
    // The first level is missing the .id, uses .key instead so we set it here so that the rest can be executed as normal
    plan.jsonSchema.$id = plan.key;
    plan.jsonSchema.id = plan.key;
    const toFix = [plan.jsonSchema];
    while (toFix.length > 0) {
        const schema = toFix.pop();
        if (schema === undefined) {
            continue;
        }
        if (schema.id !== undefined) {
            schema.$id = schema.id;
            delete schema.id;
        }
        toFix.push(...getChildrenOfProp(schema, "properties"));
        if ((schema === null || schema === void 0 ? void 0 : schema.items) !== undefined && (schema === null || schema === void 0 ? void 0 : schema.items) !== null) {
            schema.items.$id = schema.items.id;
            delete schema.items.id;
            toFix.push(...getChildrenOfProp(schema.items, "properties"));
        }
    }
    return plan;
};
/**
 * Fixes several problems with the JSONSchema returned by the API to play nice with our generator tools: quicktype and AJV
 * - Fixes the properties being nested several levels deep (to mimic the whole event structure)
 * - Fixes the IDs of the properties not being properly named for the JSONSchema draft 7 spec: removes .id, replaces with .$id
 */
function sanitizeTrackingPlan(plan) {
    var _a;
    const trackingPlan = {
        ...plan,
        // Filter only event types we support right now
        // TODO: Support more than just Track events
        rules: (_a = plan.rules) === null || _a === void 0 ? void 0 : _a.filter((rule) => rule.type === api_1.SegmentAPI.RuleType.Track).filter((rule) => {
            var _a;
            return (_a = plan.rules) === null || _a === void 0 ? void 0 : _a.every((e2) => rule.key !== e2.key || rule.version >= e2.version);
        }).map(fixProperties).map(fixJSONSchemaIds),
    };
    return (0, sort_keys_1.default)(trackingPlan, { deep: true });
}
exports.sanitizeTrackingPlan = sanitizeTrackingPlan;
function toTrackingPlanURL(workspace, id) {
    return `https://app.segment.com/${workspace}/protocols/tracking-plans/${id}`;
}
exports.toTrackingPlanURL = toTrackingPlanURL;
