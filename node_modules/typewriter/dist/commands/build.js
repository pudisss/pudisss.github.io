"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const core_1 = require("@oclif/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const api_1 = require("../api");
const base_command_1 = require("../base-command");
const config_1 = require("../config");
const languages_1 = require("../languages");
const telemetry_1 = require("../telemetry");
const FILE_HEADER = [
    "This client was automatically generated by Segment Typewriter. ** Do Not Edit **",
    "To update this file, run:",
    "  npx typewriter",
];
class Build extends base_command_1.BaseCommand {
    // clearFolder removes all typewriter-generated files from the specified folder
    // except for a plan.json.
    // It uses a simple heuristic to avoid accidentally clobbering a user's files --
    // it only clears files with the "this file was autogenerated by Typewriter" warning.
    // Therefore, all generators need to output that warning in a comment in the first few
    // lines of every generated file.
    clearFolder(dir) {
        const fileNames = fs.readdirSync(dir, "utf-8");
        for (const fileName of fileNames) {
            const fullPath = path.join(dir, fileName);
            try {
                const contents = fs.readFileSync(fullPath, "utf-8");
                if (contents.includes(FILE_HEADER[0])) {
                    this.debug("Deleting file:", fullPath);
                    fs.unlinkSync(fullPath);
                }
            }
            catch (error) {
                // Note: none of our generators produce folders, but if we ever do, then we'll need to
                // update this logic to handle recursively traversing directores. For now, we just ignore
                // any directories.
                throw error;
            }
        }
    }
    async clearGeneratedFiles(trackingPlanConfig) {
        const path = (0, config_1.resolveRelativePath)(this.configPath, trackingPlanConfig.path);
        await (0, config_1.verifyDirectoryExists)(path);
        try {
            this.debug("Clearing directory:", path);
            await this.clearFolder(path);
        }
        catch (error) {
            this.debug(`Failed to clear generated files in: '${trackingPlanConfig.path}'`);
        }
    }
    async run() {
        var _a, _b, _c, _d, _e, _f;
        const startTime = process.hrtime();
        const { flags } = await this.parse(this.constructor);
        // Check we have all the information we need
        if (this.apiToken === undefined) {
            this.warn(`No API token found at ${this.configPath}. Using local copy of tracking plans instead.`);
        }
        if (this.workspaceConfig === undefined) {
            this.error(`No workspace config found at ${this.configPath}. Run init first to generate a configuration file.`);
        }
        const configPlans = (_b = (_a = this.workspaceConfig) === null || _a === void 0 ? void 0 : _a.trackingPlans) !== null && _b !== void 0 ? _b : [];
        if (configPlans.length === 0) {
            this.error(`No tracking plans found on ${this.configPath}. Run init first to generate a config file.`);
        }
        if (flags.update === false) {
            this.log(chalk_1.default.gray(`Running build without ${chalk_1.default.yellow(`--update`)} flag. Build will not pull down tracking plan changes from Segment. \nRun ${chalk_1.default.yellow(this.rawCommand)} ${chalk_1.default.yellow(`--update`)} to fetch and build or manually update without building by running ${chalk_1.default.yellow(`typewriter update`)}.\n`));
        }
        core_1.CliUx.ux.action.start("Loading tracking plans");
        const trackingPlans = await (0, api_1.loadTrackingPlans)(this.apiToken, this.configPath, this.workspaceConfig.trackingPlans, flags.update);
        this.debug("Loaded Tracking Plans:\n", trackingPlans);
        core_1.CliUx.ux.action.stop(chalk_1.default.green(`Loaded`));
        const { language, sdk, languageOptions } = this.workspaceConfig.client;
        const languageGenerator = languages_1.supportedLanguages.find((lang) => lang.id === language);
        if (languageGenerator === undefined) {
            this.error(`Could not find a language generator for: ${language}`);
        }
        this.debug(`Generating code. Language: ${language}, SDK: ${sdk} Options:`, languageOptions);
        core_1.CliUx.ux.action.start("Generating files");
        for (const plan of trackingPlans) {
            if (plan.rules === undefined || plan.rules.length === 0) {
                core_1.CliUx.ux.action.status = chalk_1.default.yellow(`No rules found for ${plan.name}. Skipping...`);
                continue;
            }
            try {
                const files = await languageGenerator.generate((_c = plan.rules) !== null && _c !== void 0 ? _c : [], {
                    version: this.config.version,
                    isDevelopment: flags.mode === "dev",
                }, {
                    header: FILE_HEADER,
                    outputFilename: "segment",
                    sdk: sdk,
                    ...languageOptions,
                });
                const workspacePlan = this.workspaceConfig.trackingPlans.find((tp) => tp.id === plan.id || tp.legacyID === plan.id);
                await this.clearGeneratedFiles(workspacePlan);
                for (const [filename, contents] of files.entries()) {
                    // Not all quicktype languages add their extensions in the filenames returned so we check here to add it ourselves
                    let fileWithExtension = `${filename}`;
                    if (path.extname(filename) === "") {
                        fileWithExtension += `.${languageGenerator.extension}`;
                    }
                    const filepath = (0, config_1.resolveRelativePath)(this.configPath, workspacePlan.path, fileWithExtension);
                    this.debug(`Writing to ${filepath}`);
                    await (0, config_1.verifyDirectoryExists)(filepath, "file");
                    fs.writeFileSync(filepath, contents, {
                        encoding: "utf-8",
                    });
                }
            }
            catch (error) {
                core_1.CliUx.ux.action.stop(chalk_1.default.red("Error!"));
                this.error(error, {
                    message: `Failed to generate language for ${plan.name}: ${error}`,
                });
            }
        }
        core_1.CliUx.ux.action.stop(chalk_1.default.green(`Done`));
        this.segmentClient.buildCommand({
            properties: {
                config: (0, telemetry_1.toCommandConfig)(this.workspaceConfig, (_d = this.tokenMetadata) === null || _d === void 0 ? void 0 : _d.method),
                isCI: `${this.isCI}`,
                mode: flags.mode === "dev" ? telemetry_1.Mode.Dev : telemetry_1.Mode.Prod,
                workspace: (_e = this.workspace) === null || _e === void 0 ? void 0 : _e.id,
                duration: process.hrtime(startTime)[1],
                rawCommand: this.rawCommand,
            },
        });
        const afterScript = (_f = this.workspaceConfig.scripts) === null || _f === void 0 ? void 0 : _f.after;
        if (afterScript !== undefined) {
            core_1.CliUx.ux.action.start(`Running After Script: ${chalk_1.default.blue(afterScript)}`);
            await (0, config_1.runScript)(afterScript, this.configPath, config_1.Scripts.After);
            core_1.CliUx.ux.action.stop(chalk_1.default.green(`Done`));
        }
    }
}
exports.default = Build;
Build.description = "Generates types and functions for your tracking plan";
Build.aliases = ["b"];
Build.examples = [
    "<%= config.bin %> <%= command.id %>",
    "<%= config.bin %> <%= command.id %> -u",
    "<%= config.bin %> <%= command.id %> -m prod -u",
];
Build.flags = {
    ...base_command_1.BaseCommand.flags,
    update: core_1.Flags.boolean({
        char: "u",
        default: false,
        description: "Download the latest Tracking Plan version from Segment",
    }),
    mode: core_1.Flags.enum({
        options: ["dev", "prod"],
        default: "dev",
        required: false,
        char: "m",
        description: "Switch between production more or development mode (with additional validation generated for some languages)",
    }),
};
